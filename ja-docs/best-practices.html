
<!DOCTYPE html>
<head>
  <meta charset="utf-8"/>
  <style>
/*
Original Code:
https://kristall.random-projects.net/style.css
*/

pre, code {
  font-family: Menlo, Monaco, "Courier New", monospace;
}

pre {
  padding: .5rem;
  line-height: 1.0;
  overflow-x: auto;
}

@media print {
  *, *:before, *:after {
    background: transparent !important;
    color: #000 !important;
    box-shadow: none !important;
    text-shadow: none !important;
  }
  a, a:visited {
    text-decoration: underline;
  }
  a[href]:after {
    content: " (" attr(href) ")";
  }
  abbr[title]:after {
    content: " (" attr(title) ")";
  }
  a[href^="#"]:after, a[href^="javascript:"]:after {
    content: "";
  }
  pre, blockquote {
    /* border: 1px solid #999; */
    page-break-inside: avoid;
  }
  thead {
    display: table-header-group;
  }
  tr, img {
    page-break-inside: avoid;
  }
  img {
    max-width: 100% !important;
  }
  p, h2, h3 {
    orphans: 3;
    widows: 3;
  }
  h2, h3 {
    page-break-after: avoid;
  }
}

a, a:visited {
  color: #01ff70;
}

a:hover, a:focus, a:active {
  color: #2ecc40;
}

.retro-no-decoration {
  text-decoration: none;
}

html {
  font-size: 12px;
}

@media screen and (min-width: 32rem) and (max-width: 56rem) {
  html {
    font-size: 15px;
  }
}

@media screen and (min-width: 48rem) {
  html {
    font-size: 16px;
  }
}

body {
  line-height: 1.85;
}

p, .retro-p {
  font-size: 1rem;
  margin-bottom: 1.3rem;
}

h1, .retro-h1, h2, .retro-h2, h3, .retro-h3, h4, .retro-h4 {
  margin: 1.414rem 0 .5rem;
  font-weight: inherit;
  line-height: 1.42;
}

h1, .retro-h1 {
  margin-top: 0;
  font-size: 2.998rem;
}

h2, .retro-h2 {
  font-size: 1.827rem;
}

h3, .retro-h3 {
  font-size: 1.5em;
}

h4, .retro-h4 {
  font-size: 1.414rem;
}

h5, .retro-h5 {
  font-size: 1.121rem;
}

h6, .retro-h6 {
  font-size: .88rem;
}

small, .retro-small {
  font-size: .707em;
}

/* https://github.com/mrmrs/fluidity */

img, canvas, iframe, video, svg, select, textarea {
  max-width: 100%;
}

html, body {
  background-color: #222;
  min-height: 100%;
}

html {
  font-size: 18px;
}

body {
  color: #fafafa;
  font-family: "Courier New";
  line-height: 1.45;
  margin: 1rem auto 1rem;
  max-width: 56rem;
  padding: .25rem;
}

pre {
  /* background-color: #333; */
}

blockquote {
  border-left: 3px solid #01ff70;
  padding-left: 1rem;
}
  </style>
  <title>best-practices</title>
</head>
<body>
<h1>Geminiを実装してみたい人のためのベストプラクティス</h1>
<h2>イントロダクション</h2>
<p>この文書では、Geminiプロトコルを実装して利用するための様々な規約や手助けとなるスニペットについて記述します。これらは、プロトコル仕様では義務付けられていませんが、一般的には良いアイデアだと考えられています。 もしあなたがGeminiソフトウェアを書いたり、Geminiサイトを作ったりしているのであれば、正当な理由がない限り、一般的にここで示されたアドバイスに従うべきです。</p>
<h2>ファイル名</h2>
<p>Geminiサーバーは、クライアントに対して、提供するファイルのMIMEタイプを通知する必要があります。 サーバーがファイルの MIME タイプを知る最も便利な方法は、ファイル名の拡張子を利用することです。 拡張子からMIMEへのマッピングはほとんどが標準化されています (そして、UNIXシステムではしばしば /etc/mime.types ファイルがそれらでいっぱいになっています。) が、Geminiによって定義された text/gemini タイプで提供されるべきファイルをサーバがどう認識すべきか、という疑問が残ります。</p>
<p>現在のGeminiサーバーは、この目的のために .html または .gemini 拡張子を使用しているようです。新しいサーバーは、新しいものを追加するのではなく、これらのオプションのいずれかまたは両方をサポートすることが強く推奨されます。</p>
<p>ウェブサーバの慣例に従って、サーバのファイルシステム内のディレクトリにマップされるパスへのリクエストを受け取り、そのディレクトリに index.html または index.gemini という名前のファイルが存在する場合、そのパスに対してサービスが提供されます。</p>
<h2>ファイルサイズ</h2>
<p>Geminiサーバーは、提供しているファイルのサイズをクライアントに通知しないため、サーバーの障害により接続が早期に切断された場合の検出が困難な場合があります。 このような事態が発生するリスクは、ファイルサイズが大きくなるほど高くなります。</p>
<p>また、Geminiは大容量ファイルの圧縮や、ファイル破損の検出を可能にするチェックサムをサポートしていないため、そのリスクもファイルサイズに比例して高くなります。</p>
<p>これらの理由から、Geminiは「非常に大きな」ファイルの転送にはあまり適していません。 何をもって「非常に大きなファイル」とするかは、インターネット接続の速度と信頼性、そしてユーザーの忍耐力にある程度依存します。 経験則から言うと、100MBを超えるファイルは他の方法で転送するのがベストだと思われます。</p>
<p>もちろん、GeminiはURLスキームを持つあらゆるプロトコルを介した、他のオンラインコンテンツへのリンクをサポートしているので、GeminiドキュメントからHTTPS、BitTorrent、IPFSなど、あなたの好きなプロトコルを介して提供される大きなファイルへのリンクは可能です。</p>
<h2>テキストエンコーディング</h2>
<p>Geminiは、text/* MIMEタイプの 「charset」 パラメータを用いることによって、任意のテキストエンコーディングをサポートしています。 これにより、「レガシー」なテキストコンテンツを、曖昧で地域的な符号化方式で提供することができます。</p>
<p>新しいコンテンツに対しては、どうか、どうか、どうか、UTF-8を使用してください。 Geminiの仕様では、クライアントがUTF-8テキストを処理できることが必須となっています。 他のエンコーディングのサポートはクライアント次第であり、保証されていません。 UTF-8でコンテンツを提供することによって、そのアクセシビリティを最大化し、UTF-8のみをサポートするシンプルなクライアントの実用性を最大化できます。</p>
<h2>リダイレクト</h2>
<h3>一般的な見解</h3>
<p>Geminiにリダイレクト機能が搭載されたのは、主にサイトの再構築やサーバー間のサイトの移行を、既存のリンクを壊すことなく行えるようにするためです。 このような機能を持たない、ドキュメントが相互に接続された大規模な空間は、必然的に「もろい」「不安定な」(brittle)ものになります。</p>
<p>しかし、一般的にリダイレクトは厄介なものです。 リダイレクトはプロトコルの透明性を低下させ、人々がどのリンクをたどるべきか十分な情報を得た上での選択をすることを難しくし、人々のオンライン活動に関する情報を第三者に漏らす可能性があります。 GeminiではHTTPほどひどくはありませんが (CookieやRefererヘッダがないため) 、せいぜい必要悪にとどまっています。</p>
<p>そのため、リダイレクトを軽々しく使うのは控えてください。 URL短縮のようなものは、ほとんど何のメリットもありません。 一般的に、リンク切れを防ぐ以外の目的でリダイレクトを使うのは、じっくり考えてからにしてください。</p>
<h3>リダイレクトの制限</h3>
<p>クライアントは、リダイレクトに従うかどうかユーザに判断を求めることもできますし、自動的にリダイレクトに従うこともできます。 リダイレクトに自動的に従うクライアントを書く場合、以下の問題に留意するべきです。</p>
<p>誤った設定や悪意のあるGeminiサーバーは、リダイレクトに盲従するクライアントがリダイレクトの無限ループに陥ったり、非常に長いリダイレクトの連鎖を完了しなければならないような方法でリダイレクトを提供する可能性があります。 クライアントを堅牢にするためには、このような状況を検知し、それに対処するのに十分な賢さが必要でしょう。 最も単純な実装は、N個以上の連続したリダイレクトを拒否することです。 Nは5以下に設定することが推奨されます。 これはHTTPのオリジナルの勧告に沿ったものです(RFC-2068参照)。</p>
<h3>プロトコル間リダイレクト</h3>
<p>プロトコル間リダイレクト(すなわち、GeminiからGopherのような他のものへのリダイレクト)はGemini内で可能ですが、非常に強く推奨されません。 しかし、誤った設定や悪意のあるサーバは常にそのようなリダイレクトを提供しうるので、よく書かれたクライアントはそれを検知して適切に応答できるように努めるべきです。</p>
<p>一般にリダイレクトに従うクライアントであっても、HTTPやGopherのようなTLSで保護されていないプロトコルへのリダイレクトが提供された場合、クライアントがこれらのプロトコルをサポートしていると仮定して、自動的にユーザーに警告し明示的に確認を求めることが強く推奨されます。 これにより、意図しないプレーンテキストの転送を避けることができます。</p>
<h3>TLSの暗号スイート</h3>
<p>TLS 1.3は劇的にシンプルで、多くの安全でない暗号プリミティブを削除しているにもかかわらず、GeminiではTLS 1.2が不本意ながら許可されています。 これは、現在OpenSSLだけがTLS 1.3をうまくサポートしているようなので、TLS 1.3以上を要求すると、LibreSSLやBearSSLといったライブラリの利用を妨げることになるからです。</p>
<p>TLS 1.2をサポートすることを選択したクライアントとサーバーの作者は、理想的には TLS 1.3と同様のセキュリティを提供する暗号スイートのみを使用することを許可するべきです。 また、特にそのようなソフトウェアは以下のようにすべきです。</p>
<ul>
<li>前方秘匿を実現するため、鍵合意にはEphemeral Diffie-Hellman (DHE) や Ephermeral Eliptic Curve Diffie-Hellman (ECDHE) のみを使用すること</li>
<li>バルク暗号として AES または ChaCha20 を使用すること</li>
<li>メッセージの認証には、SHA2 または SHA3 系のハッシュ関数を使用すること</li>
</body></html>
